\documentclass[11pt,a4paper]{article}
\textheight245mm
\textwidth170mm
\hoffset-21mm
\voffset-15mm
\parindent0pt
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{dsfont}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{fancyhdr}
\pagestyle{fancy}

\renewcommand{\headrulewidth}{1pt}
\fancyhead[C]{Projet Programmation 1 : Rapport}
\fancyhead[L]{L3 - 2022/2023}
\fancyhead[R]{D.E.R Informatique}

\renewcommand{\footrulewidth}{1pt}
\fancyfoot[C]{\thepage} 
\fancyfoot[L]{Sacha Ben-Arous}
\fancyfoot[R]{E.N.S Paris-Saclay}

\begin{document}

\section{Typing}
\ \ \ Un lexer et un parser étant fournis, la première partie du projet consiste à faire le typing. Le principe de ce dernier est, à partir d'un AST fourni par le parser, de renvoyer un TAST (Typed AST) si le programme passé en entrée est bien typé, et sinon de renvoyer une erreur précise.
\subsection{Principe de fonctionnement}
	Il faut tout d'abord initialiser les environnements des fonctions et des structures. Pour ce faire, on utilise des \verb|Hashtables|, implémentées de manière native dans \verb|Caml|. L'utilisation de ces structures de données est pertinente car elles se redimensionnent de manière autonome, tout en gardant un coût d'accès moyen en temps constant.

	Pour implémenter l'environnement des variables, on utilise la structure de \verb|Map|, qui fonctionne comme une \verb|Hashtable|, à la différence que lorsque l'on lui ajoute un élément, cela duplique la map, permettant ainsi de gérer le \textit{shadowing} des variables de manière très pratique. \
	
Une fois les environnements implémentés, on procède en trois phases : \
\begin{itemize}
\item[\textbf{Phase 1 :}] On parcourt l'AST fourni en typant les déclarations de structures rencontrées, et en mettant à jour les environnements. Si une erreur de typage survient, on arrête le parcours et on la renvoie. De plus, on ajoute aussi de manière superficielle les structures rencontrées, afin de gérer le cas de structures inter-dépendantes. \
\item[\textbf{Phase 2 :}] On ajoute les fonctions à l'environnement, en vérifiant que les types des paramètres sont corrects, et que le type de sortie l'est aussi. On procède de même pour les champs de structures, tout en vérifiant qu'une structure ne s'utilise pas directement elle-même.
\item[\textbf{Phase 3 :}] Finalement, on parcourt récursivement le corps des fonctions rencontrées avec un filtrage pour vérifier si leur typage est correct, et on construit dans le même temps le TAST que l'on rempli avec les types rencontrés, selon la sémantique fournie.
\end{itemize}

\subsection{Problèmes rencontrés} \

Lors l'implémentation de la méthode précédemment évoquée, j'ai rencontré plusieurs problèmes : \\

\ \ \ Premièrement, la gestion du \verb|_| a demandée plusieurs implémentations différentes avant que j'en trouve une qui me satisfasse : à l'aide de filtrages, dès que je rencontre un \verb|_|, je l'ignore, en ayant au préalable vérifié le bon typage de la valeur à laquelle il était associé. \\ 

\ \ \ Ensuite, j'ai aussi rencontré des problèmes avec les structures 'quasi-récursives' dont l'exemple typique est la structure \verb|List|, dont les éléments sont composés de la tête de la liste, et d'un pointeur vers le reste de cette dernière. La fonction destinée à typer les structures ne réussissait qu'à typer 2 ou 3 niveaux d'une liste. Dès que je manipulais des objets un peu plus grand, cette fonction était incapable de les typer en profondeur. Je n'ai pas réussi à régler ce problème. \\

\section{Compilation}

	Maintenant que le typing est fait, il faut traduire notre language \verb|NanoGo| vers un language bas-niveau comme l'\verb|Assembly x86_64|.  

\subsection{Principe de fonctionnement}

Comme précédemment, une fonction récursive va parcourir le programme, et grâce à un filtrage, on va pouvoir traduire le fichier fourni à partir de cas 'atomiques'. Un invariant de cette fonction de parcours est que à chaque appel, l'adresse de l'expression évaluée se trouve dans le registre \verb|%rdi|. Du code \verb|Asm x86_64| déjà pratiqué en majeur partie dans le précédent projet permet d'implémenter tous les cas, sauf ceux où il faut créer une nouvelle variable, pour lesquels il faut utiliser \verb|allocz|. De plus, des fonctions d'affichage pour chaque type étaient nécessaires, (mais la plupart étaient fournies dans le code assembleur servant d'exemple !).

\subsection{Problèmes rencontrés} \

\ \ \ Tout d'abord, j'ai eu de nombreuses fois des erreurs dans mon code généré en confondant les écritures \verb|(%rdi)| et \verb|%rdi|, la première représentant l'adresse de ce qui est stocké dans \verb|%rdi|, alors que la seconde renvoie simplement la valeur de ce qui y est stocké. \\

\ \ \ Ensuite, un autre problème (assez mysterieux) qui s'est posé a été celui des boucles \verb|for|. En effet, le code que je met à l'intérieur de celles-ci n'est jamais éxécuté, mais ne fournit pas d'erreurs non plus ! De plus, ce genre problème ne se pose que dans ce cas là, les \verb|if| fonctionnant très bien par exemple. Je n'ai pas réussi à régler ce problème. \\


\ \ \ Finalement, le plus gros problème que j'ai eu est celui de l'implémentation des structures en assembleur. De multiples problématiques se posent : comment stocker dans des registres les éléments d'une structure ayant une taille particulière, dépassant les tailles usuellement manipulées ; comment gérer les redirections de pointeurs ou de mémoire vers des objets qui peuvent êtres déplacés/supprimés/modifiés. Face à tous ces problèmes, j'ai abandonné l'idée d'implémenter les structures.

\end{document}
